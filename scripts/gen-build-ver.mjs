import fs from 'fs';
import path from 'path';

/**
 * Cloudflare Pages build hook: generates a single cache-busting version value.
 * - Writes /assets/js/build.ver.js (read by build.loader.js)
 * - Writes /build.txt (quick deploy verification)
 *
 * Works on Cloudflare Pages and also on GitHub Actions/local.
 */

function safe(s) {
  return (s || '').toString().trim();
}

function nowStamp() {
  // YYYYMMDD-HHMM
  const d = new Date();
  const pad = (n) => String(n).padStart(2, '0');
  return (
    d.getUTCFullYear() +
    pad(d.getUTCMonth() + 1) +
    pad(d.getUTCDate()) +
    '-' +
    pad(d.getUTCHours()) +
    pad(d.getUTCMinutes())
  );
}

const sha = safe(process.env.CF_PAGES_COMMIT_SHA) || safe(process.env.GITHUB_SHA) || '';
const shortSha = sha ? sha.slice(0, 7) : '';
const branch = safe(process.env.CF_PAGES_BRANCH) || safe(process.env.GITHUB_REF_NAME) || '';
const stamp = nowStamp();

// Example: v20260220-0645-1a2b3c4 (branch optional)
let buildVer = `v${stamp}`;
if (shortSha) buildVer += `-${shortSha}`;
if (branch) buildVer += `-${branch.replace(/[^a-zA-Z0-9._-]/g, '_')}`;

// ---- Auto-detect core global assets (folder scan) ----
function readDirFiles(dir) {
  try {
    return fs.readdirSync(dir, { withFileTypes: true })
      .filter((d) => d.isFile())
      .map((d) => d.name);
  } catch {
    return [];
  }
}

function pickLatestByVersion(files, re, versionIndex = 1) {
  let best = null;
  let bestV = -1;
  for (const f of files) {
    const m = f.match(re);
    if (!m) continue;
    const v = parseInt(m[versionIndex] || '0', 10);
    if (Number.isFinite(v) && v >= 0 && v > bestV) {
      bestV = v;
      best = f;
    }
  }
  return best;
}

function pickHeaderBundle(jsDir, jsFiles) {
  // Heuristics (robust): choose the hashed j.<hash>.js that likely contains header/menu injection.
  const candidates = jsFiles.filter((f) => /^j\.[a-z0-9]+\.js$/i.test(f));
  if (!candidates.length) return null;

  const markers = [
    { str: '88ST.CLOUD', score: 1000 },
    { str: '__88stRefreshUserMenu', score: 900 },
    { str: '__88stAddRecent', score: 700 },
    { str: 'userMenu', score: 400 },
    { str: 'header', score: 250 },
  ];

  let best = null;
  let bestScore = -1;

  for (const f of candidates) {
    const p = path.join(jsDir, f);
    let score = 0;
    let size = 0;
    try {
      const st = fs.statSync(p);
      size = st.size || 0;
      score += Math.min(200, Math.floor(size / 8000)); // slight preference for bigger bundles
    } catch {}

    try {
      const buf = fs.readFileSync(p);
      for (const m of markers) {
        if (buf.includes(Buffer.from(m.str))) score += m.score;
      }
    } catch {}

    if (score > bestScore) {
      bestScore = score;
      best = f;
    }
  }

  // Fallback: keep previous known filename if present
  const known = 'j.8829a3ccde44.js';
  if (!best && jsFiles.includes(known)) return known;
  return best || (jsFiles.includes(known) ? known : candidates[0]);
}

const root = process.cwd();
const cssDir = path.join(root, 'assets', 'css');
const jsDir = path.join(root, 'assets', 'js');

const cssFiles = readDirFiles(cssDir);
const jsFiles = readDirFiles(jsDir);

const luxeCss = pickLatestByVersion(cssFiles, /^vvip-luxe\.v(\d+)\.css$/i);
const hubCss  = pickLatestByVersion(cssFiles, /^vvip-hub\.v(\d+)\.css$/i);
const patchCss = pickLatestByVersion(cssFiles, /^patch\.v(\d+).*\.css$/i);

const globalJs = pickLatestByVersion(jsFiles, /^vvip-global\.v(\d+)\.js$/i);
const searchTypingJs = pickLatestByVersion(jsFiles, /^j\.searchtyping\.v(\d+)\./i);
const headerJs = pickHeaderBundle(jsDir, jsFiles);

const buildAssets = {
  css: [luxeCss, hubCss, patchCss].filter(Boolean).map((f) => `/assets/css/${f}`),
  js: [globalJs, searchTypingJs, headerJs].filter(Boolean).map((f) => `/assets/js/${f}`),
};

const verJs = `/**\n * Auto-generated at build time.\n * Do NOT edit this file manually.\n */\nwindow.__BUILD_VER = ${JSON.stringify(buildVer)};\nwindow.__BUILD_ASSETS = ${JSON.stringify(buildAssets)};\n`;
const outVer = path.join(root, 'assets', 'js', 'build.ver.js');
const outTxt = path.join(root, 'build.txt');

fs.mkdirSync(path.dirname(outVer), { recursive: true });
fs.writeFileSync(outVer, verJs, 'utf8');

const txt = [
  `build=${buildVer}`,
  shortSha ? `commit=${shortSha}` : `commit=` ,
  branch ? `branch=${branch}` : `branch=`,
  `assets_css=${buildAssets.css.join(',')}`,
  `assets_js=${buildAssets.js.join(',')}`,
  `generated_utc=${new Date().toISOString()}`,
].join('\n') + '\n';
fs.writeFileSync(outTxt, txt, 'utf8');

console.log('Generated build.ver.js ->', buildVer);
console.log('Wrote build.txt');
